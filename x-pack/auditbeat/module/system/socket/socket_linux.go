// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License;
// you may not use this file except in compliance with the Elastic License.

// +build linux,386 linux,amd64

package socket

import (
	"context"
	"fmt"
	"strconv"
	"strings"
	"sync/atomic"
	"time"
	"unsafe"

	"github.com/pkg/errors"
	"golang.org/x/sys/unix"

	"github.com/elastic/beats/v7/libbeat/common"
	"github.com/elastic/beats/v7/libbeat/common/cfgwarn"
	"github.com/elastic/beats/v7/libbeat/logp"
	"github.com/elastic/beats/v7/metricbeat/mb"
	"github.com/elastic/beats/v7/x-pack/auditbeat/module/system"
	"github.com/elastic/beats/v7/x-pack/auditbeat/module/system/socket/dns"
	"github.com/elastic/beats/v7/x-pack/auditbeat/module/system/socket/guess"
	"github.com/elastic/beats/v7/x-pack/auditbeat/module/system/socket/helper"
	"github.com/elastic/beats/v7/x-pack/auditbeat/tracing"
	"github.com/elastic/go-perf"
	"github.com/elastic/go-sysinfo"

	// Register dns capture implementations
	_ "github.com/elastic/beats/v7/x-pack/auditbeat/module/system/socket/dns/afpacket"
)

const (
	moduleName      = "system"
	metricsetName   = "socket"
	fullName        = moduleName + "/" + metricsetName
	namespace       = "system.audit.socket"
	detailSelector  = metricsetName + "detailed"
	groupNamePrefix = "auditbeat_"
	// Magic value to detect clock-sync events generated by the metricset.
	clockSyncMagic uint64 = 0x42DEADBEEFABCDEF
)

var (
	eventCount uint64
)

// MetricSet for system/socket.
type MetricSet struct {
	system.SystemMetricSet
	config     Config
	log        *logp.Logger
	detailLog  *logp.Logger
	engine     *tracing.Engine
	sniffer    dns.Sniffer
	isDebug    bool
	isDetailed bool
}

func init() {
	mb.Registry.MustAddMetricSet(moduleName, metricsetName, New,
		mb.DefaultMetricSet(),
		mb.WithNamespace(namespace),
	)
}

// New constructs a new MetricSet.
func New(base mb.BaseMetricSet) (mb.MetricSet, error) {
	cfgwarn.Beta("The %s dataset is beta.", fullName)

	config := defaultConfig
	if err := base.Module().UnpackConfig(&config); err != nil {
		return nil, errors.Wrapf(err, "failed to unpack the %s config", fullName)
	}
	logger := logp.NewLogger(metricsetName)
	sniffer, err := dns.NewSniffer(base, logger)
	if err != nil {
		return nil, errors.Wrap(err, "unable to create DNS sniffer")
	}

	ms := &MetricSet{
		SystemMetricSet: system.NewSystemMetricSet(base),
		config:          config,
		log:             logger,
		isDebug:         logp.IsDebug(metricsetName),
		detailLog:       logp.NewLogger(detailSelector),
		isDetailed:      logp.HasSelector(detailSelector),
		sniffer:         sniffer,
	}

	hasIPv6, err := detectIPv6()
	if err != nil {
		ms.log.Debugf("Error detecting IPv6 support: %v", err)
		hasIPv6 = false
	}
	ms.log.Debugf("IPv6 supported: %v", hasIPv6)
	if ms.config.EnableIPv6 != nil {
		if *ms.config.EnableIPv6 && !hasIPv6 {
			return nil, errors.New("requested IPv6 support but IPv6 is disabled in the system")
		}
		hasIPv6 = *ms.config.EnableIPv6
	}
	ms.log.Debugf("IPv6 enabled: %v", hasIPv6)

	cfg := []tracing.ConfigFn{
		tracing.WithPerfChannelConf(
			tracing.WithTID(perf.AllThreads),
			tracing.WithBufferSize(ms.config.PerfQueueSize),
			tracing.WithErrBufferSize(ms.config.ErrQueueSize),
			tracing.WithLostBufferSize(ms.config.LostQueueSize),
			tracing.WithRingSizeExponent(ms.config.RingSizeExp),
		),
		tracing.WithAutoMount(true),
		tracing.WithLogger(ms.log),
		tracing.WithTemplateVars(common.MapStr{
			"HAS_IPV6":    hasIPv6,
			"AF_INET":     2,
			"AF_INET6":    10,
			"IPPROTO_TCP": 6,
			"IPPROTO_UDP": 17,
			"SOCK_STREAM": 2,
			"TCP_CLOSED":  7,
			// TODO: Move to main package
			// Offset of the ith element on an array of pointers
			"POINTER_INDEX": func(index int) int {
				return int(unsafe.Sizeof(uintptr(0))) * index
			},
		}),
		tracing.WithSymbolResolution("IP_LOCAL_OUT", []string{"ip_local_out", "ip_local_out_sk"}),
		tracing.WithSymbolResolution("RECV_UDP_DATAGRAM", []string{"__skb_recv_udp", "__skb_recv_datagram", "skb_recv_datagram"}),
		tracing.WithSyscall("SYS_EXECVE", "execve"),
		tracing.WithSyscall("SYS_GETTIMEOFDAY", "gettimeofday"),
		tracing.WithSyscall("SYS_UNAME", "newuname"),
		tracing.WithProbes(getKProbes(hasIPv6)...),
		tracing.WithGuesses(guess.Registry.GetList()...),
	}
	if ms.config.TraceFSPath != nil {
		cfg = append(cfg, tracing.WithTraceFSPath(*ms.config.TraceFSPath))
	}
	if ms.config.DevelopmentMode {
		cfg = append(cfg, tracing.WithTransform(filterPort(22)))
	}
	if ms.engine, err = tracing.New(groupNamePrefix, cfg...); err != nil {
		return nil, errors.Wrap(err, "creating probe engine")
	}
	return ms, ms.engine.Setup()
}

// Run the metricset. This will loop until the passed reporter is cancelled.
func (m *MetricSet) Run(r mb.PushReporterV2) {
	defer m.log.Infof("%s terminated.", fullName)
	defer func() {
		if err := m.engine.Stop(); err != nil {
			m.log.Errorf("Stopping probe engine: %v", err)
		}
	}()
	st := NewState(r,
		m.log,
		m.config.FlowInactiveTimeout,
		m.config.SocketInactiveTimeout,
		m.config.FlowTerminationTimeout,
		m.config.ClockMaxDrift)

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	if err := m.sniffer.Monitor(ctx, func(tr dns.Transaction) {
		if err := st.OnDNSTransaction(tr); err != nil {
			m.log.Errorf("Unable to store DNS transaction %+v: %v", tr, err)
		}
	}); err != nil {
		err = errors.Wrap(err, "unable to start DNS sniffer")
		r.Error(err)
		m.log.Error(err)
		return
	}
	if err := m.engine.Start(); err != nil {
		err = errors.Wrap(err, "unable to start kprobe tracing engine")
		r.Error(err)
		m.log.Error(err)
		return
	}

	// Launch the clock-synchronization ticker.
	go m.clockSyncLoop(m.config.ClockSyncPeriod, r.Done())

	if procs, err := sysinfo.Processes(); err != nil {
		m.log.Error("Failed to bootstrap process table using /proc", err)
	} else {
		for _, p := range procs {
			if i, err := p.Info(); err == nil {
				process := process{
					name:        i.Name,
					pid:         uint32(i.PID),
					args:        i.Args,
					createdTime: i.StartTime,
					path:        i.Exe,
				}

				if user, err := p.User(); err == nil {
					toUint32 := func(id string) uint32 {
						num, _ := strconv.Atoi(id)
						return uint32(num)
					}
					process.uid = toUint32(user.UID)
					process.euid = toUint32(user.EUID)
					process.gid = toUint32(user.GID)
					process.egid = toUint32(user.EGID)
					process.hasCreds = true
				}

				st.CreateProcess(process)
			}
		}
		m.log.Info("Bootstrapped process table using /proc")
	}

	m.log.Infof("%s dataset is running.", fullName)
	// Dispatch loop.
	for running := true; running; {
		select {
		case <-r.Done():
			running = false

		case iface, ok := <-m.engine.C():
			if !ok {
				running = false
				break
			}
			v, ok := iface.(event)
			if !ok {
				m.log.Errorf("Received an event of wrong type: %T", iface)
				continue
			}
			if m.isDetailed {
				m.detailLog.Debug(v.String())
			}
			if err := v.Update(st); err != nil && m.isDetailed {
				// These errors are seldom interesting, as the flow state engine
				// doesn't have many error conditions and all benign enough to
				// not be worth logging them by default.
				m.detailLog.Warnf("Issue while processing event '%s': %v", v.String(), err)
			}
			atomic.AddUint64(&eventCount, 1)

		case err := <-m.engine.ErrC():
			m.log.Errorf("Error received from perf channel: %v", err)
			running = false

		case numLost := <-m.engine.LostC():
			if numLost != ^uint64(0) {
				m.log.Warnf("Lost %d events", numLost)
			} else {
				m.log.Warn("Lost the whole ringbuffer")
			}
		}
	}
}

func (m *MetricSet) clockSyncLoop(interval time.Duration, done <-chan struct{}) {
	ticker := time.NewTicker(interval)
	defer ticker.Stop()
	triggerClockSync()
	for {
		select {
		case <-done:
			return
		case <-ticker.C:
			triggerClockSync()
		}
	}
}

func triggerClockSync() {
	// This generates a uname (SYS_UNAME) syscall event that contains
	// clockSyncMagic at the first 8 bytes of the passed buffer and
	// the current UNIX nano timestamp at the following 8 bytes.
	//
	// The magic bytes are used to filter-out legitimate uname() calls
	// from this process and the timestamp is used as a reference point for
	// synchronization with the internal clock that the kernel uses for stamping
	// the tracing events it produces.
	var buf unix.Utsname
	tracing.MachineEndian.PutUint64(buf.Sysname[:], clockSyncMagic)
	tracing.MachineEndian.PutUint64(buf.Sysname[8:], uint64(time.Now().UnixNano()))
	unix.Uname(&buf)
}

func detectIPv6() (bool, error) {
	// Check that AF_INET6 is available.
	// This fails when the kernel is booted with ipv6.disable=1
	fd, err := unix.Socket(unix.AF_INET6, unix.SOCK_DGRAM, 0)
	if err != nil {
		return false, nil
	}
	unix.Close(fd)
	loopback, err := helper.NewIPv6Loopback()
	if err != nil {
		return false, err
	}
	defer loopback.Cleanup()
	_, err = loopback.AddRandomAddress()
	// Assume that all failures for Add..() are caused by missing IPv6 support.
	return err == nil, nil
}

// filterPort is used for filtering port 22 traffic when debugging over
// an SSH connection. Otherwise there is a feedback loop when tracing events
// printed on the terminal are transmitted over SSH, which causes more tracing
// events.
func filterPort(portnum uint16) tracing.ProbeTransform {
	var buf [2]byte
	tracing.MachineEndian.PutUint16(buf[:], portnum)
	filter := fmt.Sprintf("lport!=0x%02x%02x", buf[0], buf[1])
	return func(probe tracing.ProbeDef) tracing.ProbeDef {
		if strings.Contains(probe.Probe.Fetchargs, "lport=") {
			if probe.Probe.Filter == "" {
				probe.Probe.Filter = filter
			} else {
				probe.Probe.Filter = fmt.Sprintf("%s && (%s)",
					filter, probe.Probe.Filter)
			}
		}
		return probe
	}
}
