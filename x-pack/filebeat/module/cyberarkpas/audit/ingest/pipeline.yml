---
description: Pipeline for CyberArk PAS

processors:
  #
  # Set ECS event.ingested
  #
  - set:
        field: event.ingested
        value: '{{_ingest.timestamp}}'

  #
  # Save event.original
  # TODO: Config flag.
  #
  - rename:
      field: message
      target_field: event.original

  #
  # Parse syslog headers (if any) and extract JSON payload.
  #
  - grok:
      field: event.original
      patterns:
        # RFC5424 from Cyberark.
        # UseLegacySyslogFormat=No
        # <5>1 2021-03-04T17:28:23Z VAULT {"format":"elastic","version":"1.0",...}
        - "^<%{NONNEGINT:log.syslog.severity.code}>%{NONNEGINT} %{TIMESTAMP_ISO8601:@timestamp} %{SYSLOGHOST:observer.hostname} %{JSON_PAYLOAD:_tmp.payload}"

        # Default Legacy format.
        # UseLegacySyslogFormat=Yes
        # Mar 08 02:57:42 VAULT {"format":"elastic","version":"1.0"
        - "^%{SYSLOGTIMESTAMP:_tmp.syslog_ts} %{SYSLOGHOST:observer.hostname} %{JSON_PAYLOAD:_tmp.payload}"

        # Catch-all mode, just JSON payload.
        - "%{JSON_PAYLOAD:_tmp.payload}"
      pattern_definitions:
        JSON_PAYLOAD: '{"format":"elastic","version":"1.0",.*}'
      on_failure:
        - fail:
            message: "unexpected event format: {{ _ingest.on_failure_message }}"

  - json:
      field: _tmp.payload
      target_field: _tmp.json
      on_failure:
        - fail:
            message: "malformed JSON event: {{ _ingest.on_failure_message }}"

  - rename:
      field: _tmp.json.syslog.audit_record
      target_field: cyberarkpas.audit
      on_failure:
        - fail:
            message: "unexpected event structure: {{ _ingest.on_failure_message }}"


  #
  # Remove all empty fields
  #
  - script:
      lang: painless
      params:
        values: [""]
      source: >-
        ctx.cyberarkpas.audit.entrySet().removeIf(entry -> params.values.contains(entry.getValue()));

  - rename:
      field: _tmp.json.raw
      target_field: cyberarkpas.audit.raw
      ignore_missing: true

  # Parse the syslog timestamp when the logs are emitted in legacy format.
  # In this case, this is the only timestamp present in the event, and in the
  # default configuration it doesn't include a year.
  - date:
      if: 'ctx._tmp?.syslog_ts != null'
      field: _tmp.syslog_ts
      # TODO: Timezone?
      formats:
        # This is the default format.
        - 'MMM dd HH:mm:ss'
        # Drop a few other formats in case the above fails.
        - ISO8601
        - 'MMM  d HH:mm:ss'
        - "EEE MMM dd HH:mm:ss"
        - "EEE MMM  d HH:mm:ss"
        - "MMM  d HH:mm:ss z"
        - "MMM dd HH:mm:ss z"
        - "EEE MMM  d HH:mm:ss z"
        - "EEE MMM dd HH:mm:ss z"
        - "MMM  d yyyy HH:mm:ss"
        - "MMM dd yyyy HH:mm:ss"
        - "EEE MMM  d yyyy HH:mm:ss"
        - "EEE MMM dd yyyy HH:mm:ss"
        - "MMM  d yyyy HH:mm:ss z"
        - "MMM dd yyyy HH:mm:ss z"
        - "EEE MMM  d yyyy HH:mm:ss z"
        - "EEE MMM dd yyyy HH:mm:ss z"
      on_failure:
        - append:
            field: error.message
            value: "failed to parse legacy syslog timestamp: {{ _tmp.syslog_ts }}: {{ _ingest.on_failure_message }}"

  # Parse IsoTimestamp field.
  - date:
      if: 'ctx.cyberarkpas.audit.IsoTimestamp != null'
      field: cyberarkpas.audit.IsoTimestamp
      formats:
        - ISO8601
      on_failure:
        - append:
            field: error.message
            value: "failed to parse ISO timestamp field: {{ cyberarkpas.audit.IsoTimestamp }}: {{ _ingest.on_failure_message }}"

  # Parse Timestamp field only if @timestamp not already set.
  - date:
      if: 'ctx.cyberarkpas.audit.Timestamp != null && ctx["@timestamp"] == null'
      field: cyberarkpas.audit.Timestamp
      formats:
        # This is the default format.
        - 'MMM dd HH:mm:ss'
        # Drop a few other formats in case the above fails.
        - ISO8601
        - 'MMM  d HH:mm:ss'
        - "EEE MMM dd HH:mm:ss"
        - "EEE MMM  d HH:mm:ss"
        - "MMM  d HH:mm:ss z"
        - "MMM dd HH:mm:ss z"
        - "EEE MMM  d HH:mm:ss z"
        - "EEE MMM dd HH:mm:ss z"
        - "MMM  d yyyy HH:mm:ss"
        - "MMM dd yyyy HH:mm:ss"
        - "EEE MMM  d yyyy HH:mm:ss"
        - "EEE MMM dd yyyy HH:mm:ss"
        - "MMM  d yyyy HH:mm:ss z"
        - "MMM dd yyyy HH:mm:ss z"
        - "EEE MMM  d yyyy HH:mm:ss z"
        - "EEE MMM dd yyyy HH:mm:ss z"
      on_failure:
        - append:
            field: error.message
            value: "failed to parse timestamp field: {{ cyberarkpas.audit.Timestamp }}: {{ _ingest.on_failure_message }}"

  # This script converts the nested object under cyberarkpas.audit.CAProperties.CAProperty
  # into an object under cyberarkpas.audit.CAProperties:
  #
  # input:
  # "cyberarkpas.audit.CAProperties.CAProperty": [
  #            {
  #                "Name": "PolicyID",
  #                "Value": "LINUX-SSH"
  #            },
  #            {
  #                "Name": "UserName",
  #                "Value": "test12"
  #            }
  # output:
  # "cyberarkpas.audit.CAProperties":
  #            {
  #                "PolicyID": ["LINUX-SSH"],
  #                "UserName": ["test12"]
  #            }
  - foreach:
      field: cyberarkpas.audit.CAProperties.CAProperty
      ignore_missing: true
      processor:
        set:
          field: 'cyberarkpas.audit.CAProperties.{{_ingest._value.Name}}'
          value: '{{_ingest._value.Value}}'
      on_failure:
        - append:
            field: error.message
            value: "failed to process CAProperties array: {{ _ingest.on_failure_message }}"

  # Parse key-value pairs at ExtraDetails:
  # input:
  #   "cyberarkpas.audit.ExtraDetails": "Command=ls \"/var/tmp\";ConnectionComponentId=PSMP-SSH;DstHost=[...]",
  #
  # output:
  #   "cyberarkpas.audit.ExtraDetails":
  #     {
  #       "Command": "ls \"/var/tmp\"",
  #       "ConnectionComponentId": "PSMP-SSH",
  #       "DstHost": [...]
  #
  # The original string can contain escaped separators, \= and \;
  - kv:
      field: cyberarkpas.audit.ExtraDetails
      field_split: '(?<!\\);' # unescaped ;
      value_split: '(?<!\\)=' # uneescaped =
      target_field: _tmp.kv
      ignore_missing: true
      on_failure:
        - append:
            field: error.message
            value: "failed to process ExtraDetails expression '{{ cyberarkpas.audit.ExtraDetails }}': {{ _ingest.on_failure_message }}"
  - remove:
      field: cyberarkpas.audit.ExtraDetails
      ignore_missing: true

  - rename:
      field: _tmp.kv
      target_field: cyberarkpas.audit.ExtraDetails
      ignore_missing: true

  #
  # Cleanup
  #
  - remove:
      field:
       - _tmp
       - cyberarkpas.audit.CAProperties.CAProperty
      ignore_missing: true

  #
  # ECS enrichment
  #
  - set:
      field: event.code
      value: '{{ cyberarkpas.audit.MessageID }}'
      if: 'ctx.cyberarkpas.audit?.MessageID != null && ctx.cyberarkpas.audit.MessageID != ""'

  #
  # Convert field names from CamelCase to snake_case.
  #
  - script:
      lang: painless
      source: >
        String to_snake(String key) {
          int run = 0;
          boolean first = true;
          StringBuilder result = new StringBuilder();
          for (char c : key.toCharArray()) {
            char o = Character.toLowerCase(c);
            if (c != o) {
              if (run == 0 && !first) {
                result.append('_');
              }
              run ++;
            } else {
              if (run > 1) {
                char prev = result.charAt(result.length()-1);
                result.setCharAt(result.length()-1, (char)'_');
                result.append(prev);
              }
              run = 0;
              first = false;
            }
            result.append(o);
          }
          return result.toString();
        }
        def convert(Map object) {
          return object.entrySet().stream().collect(
            Collectors.toMap(
              e -> to_snake(e.getKey()),
              e -> (e.getValue() instanceof Map? convert(e.getValue()) : e.getValue())
            )
          );
        }
        ctx.cyberarkpas.audit = convert(ctx.cyberarkpas.audit);

on_failure:
  - append:
        field: error.message
        value: "{{ _ingest.on_failure_message }}"
  - remove:
      field:
        - _tmp
      ignore_missing: true
