---
description: Pipeline for CyberArk PAS

processors:
  #
  # Set ECS event.ingested
  #
  - set:
        field: event.ingested
        value: '{{_ingest.timestamp}}'

  #
  # Save event.original
  # TODO: Config flag.
  #
  - rename:
      field: message
      target_field: event.original

  #
  # Parse syslog headers (if any) and extract JSON payload.
  #
  - grok:
      field: event.original
      patterns:
        # RFC5424 from Cyberark.
        # UseLegacySyslogFormat=No
        # <5>1 2021-03-04T17:28:23Z VAULT {"format":"elastic","version":"1.0",...}
        - "^<%{NONNEGINT:log.syslog.severity.code}>%{NONNEGINT} %{TIMESTAMP_ISO8601:_tmp.syslog_ts} %{SYSLOGHOST:observer.hostname} %{JSON_PAYLOAD:_tmp.payload}"

        # Default Legacy format.
        # UseLegacySyslogFormat=Yes
        # Mar 08 02:57:42 VAULT {"format":"elastic","version":"1.0"
        - "^%{SYSLOGTIMESTAMP:_tmp.syslog_ts} %{SYSLOGHOST:observer.hostname} %{JSON_PAYLOAD:_tmp.payload}"

        # Catch-all mode, just JSON payload.
        - "%{JSON_PAYLOAD:_tmp.payload}"
      pattern_definitions:
        JSON_PAYLOAD: '{"format":"elastic","version":"1.0",.*}'
      on_failure:
        - fail:
            message: "unexpected event format: {{ _ingest.on_failure_message }}"

  - json:
      field: _tmp.payload
      target_field: _tmp.json
      on_failure:
        - fail:
            message: "malformed JSON event: {{ _ingest.on_failure_message }}"

  - rename:
      field: _tmp.json.syslog.audit_record
      target_field: cyberarkpas.audit
      on_failure:
        - fail:
            message: "unexpected event structure: {{ _ingest.on_failure_message }}"


  #
  # Remove all empty fields
  #
  - script:
      lang: painless
      source: >-
        ctx.cyberarkpas.audit.entrySet().removeIf(entry -> entry.getValue() == "");

  - rename:
      field: _tmp.json.raw
      target_field: cyberarkpas.audit.raw
      ignore_missing: true

  # The following processors populate @timestamp from the different sources that can exist in an event.
  # In the following order of precedence:
  # - IsoTimestamp field (expected ISO8601). Present when new syslog format is used (rfc5424: yes).
  # - Timestamp (expected MMM dd HH:mm:ss). Also present only when new syslog format is used.
  # - Syslog header timestamp. Either ISO8601 or legacy MMM dd HH:mm:ss, depending on the syslog format in use.
  # - Original @timestamp from Filebeat.
  - date:
      if: 'ctx.cyberarkpas.audit.IsoTimestamp != null'
      field: cyberarkpas.audit.IsoTimestamp
      target_field: _tmp.timestamp
      formats:
        - ISO8601
      on_failure:
        - append:
            field: error.message
            value: "failed to parse ISO timestamp field: {{ cyberarkpas.audit.IsoTimestamp }}: {{ _ingest.on_failure_message }}"

  - date:
      if: 'ctx._tmp.timestamp == null && ctx.cyberarkpas.audit.Timestamp != null'
      field: cyberarkpas.audit.Timestamp
      target_field: _tmp.timestamp
      formats:
        # This is the default format.
        - 'MMM dd HH:mm:ss'
        # Drop a few other formats in case the above fails.
        - ISO8601
        - 'MMM  d HH:mm:ss'
        - "EEE MMM dd HH:mm:ss"
        - "EEE MMM  d HH:mm:ss"
        - "MMM  d HH:mm:ss z"
        - "MMM dd HH:mm:ss z"
        - "EEE MMM  d HH:mm:ss z"
        - "EEE MMM dd HH:mm:ss z"
        - "MMM  d yyyy HH:mm:ss"
        - "MMM dd yyyy HH:mm:ss"
        - "EEE MMM  d yyyy HH:mm:ss"
        - "EEE MMM dd yyyy HH:mm:ss"
        - "MMM  d yyyy HH:mm:ss z"
        - "MMM dd yyyy HH:mm:ss z"
        - "EEE MMM  d yyyy HH:mm:ss z"
        - "EEE MMM dd yyyy HH:mm:ss z"
      on_failure:
        - append:
            field: error.message
            value: "failed to parse timestamp field: {{ cyberarkpas.audit.Timestamp }}: {{ _ingest.on_failure_message }}"

  - date:
      if: 'ctx._tmp.timestamp == null && ctx._tmp.syslog_ts != null'
      field: _tmp.syslog_ts
      target_field: _tmp.timestamp
      # TODO: Timezone?
      formats:
        # This is the default format.
        - 'MMM dd HH:mm:ss'
        # Drop a few other formats in case the above fails.
        - ISO8601
        - 'MMM  d HH:mm:ss'
        - "EEE MMM dd HH:mm:ss"
        - "EEE MMM  d HH:mm:ss"
        - "MMM  d HH:mm:ss z"
        - "MMM dd HH:mm:ss z"
        - "EEE MMM  d HH:mm:ss z"
        - "EEE MMM dd HH:mm:ss z"
        - "MMM  d yyyy HH:mm:ss"
        - "MMM dd yyyy HH:mm:ss"
        - "EEE MMM  d yyyy HH:mm:ss"
        - "EEE MMM dd yyyy HH:mm:ss"
        - "MMM  d yyyy HH:mm:ss z"
        - "MMM dd yyyy HH:mm:ss z"
        - "EEE MMM  d yyyy HH:mm:ss z"
        - "EEE MMM dd yyyy HH:mm:ss z"
      on_failure:
        - append:
            field: error.message
            value: "failed to parse legacy syslog timestamp: {{ _tmp.syslog_ts }}: {{ _ingest.on_failure_message }}"

  - set:
      field: '@timestamp'
      value: '{{ _tmp.timestamp }}'
      ignore_empty_value: true
      override: true

  # This script converts the nested object under cyberarkpas.audit.CAProperties.CAProperty
  # into an object under cyberarkpas.audit.CAProperties:
  #
  # input:
  # "cyberarkpas.audit.CAProperties.CAProperty": [
  #            {
  #                "Name": "PolicyID",
  #                "Value": "LINUX-SSH"
  #            },
  #            {
  #                "Name": "UserName",
  #                "Value": "test12"
  #            }
  # output:
  # "cyberarkpas.audit.CAProperties":
  #            {
  #                "PolicyID": ["LINUX-SSH"],
  #                "UserName": ["test12"]
  #            }
  - foreach:
      field: cyberarkpas.audit.CAProperties.CAProperty
      ignore_missing: true
      processor:
        set:
          field: 'cyberarkpas.audit.CAProperties.{{_ingest._value.Name}}'
          value: '{{_ingest._value.Value}}'
      on_failure:
        - append:
            field: error.message
            value: "failed to process CAProperties array: {{ _ingest.on_failure_message }}"

  # Parse key-value pairs at ExtraDetails:
  # input:
  #   "cyberarkpas.audit.ExtraDetails": "Command=ls \"/var/tmp\";ConnectionComponentId=PSMP-SSH;DstHost=[...]",
  #
  # output:
  #   "cyberarkpas.audit.ExtraDetails":
  #     {
  #       "Command": "ls \"/var/tmp\"",
  #       "ConnectionComponentId": "PSMP-SSH",
  #       "DstHost": [...]
  #
  # The original string can contain escaped separators, \= and \;
  - kv:
      field: cyberarkpas.audit.ExtraDetails
      field_split: '(?<!\\);' # unescaped ;
      value_split: '(?<!\\)=' # uneescaped =
      target_field: _tmp.kv
      ignore_missing: true
      on_failure:
        - append:
            field: error.message
            value: "failed to process ExtraDetails expression '{{ cyberarkpas.audit.ExtraDetails }}': {{ _ingest.on_failure_message }}"
  - remove:
      field: cyberarkpas.audit.ExtraDetails
      ignore_missing: true

  - rename:
      field: _tmp.kv
      target_field: cyberarkpas.audit.ExtraDetails
      ignore_missing: true

  #
  # Cleanup
  #
  - remove:
      field:
       - _tmp
       - cyberarkpas.audit.CAProperties.CAProperty
      ignore_missing: true

  #
  # Convert field names from CamelCase to snake_case.
  #
  - script:
      lang: painless
      source: >
        String to_snake_case(String s) {
          /* faster code path for strings that won't need an underscore */
          if (s.chars().skip(1).noneMatch(Character::isUpperCase)) {
            return s.toLowerCase();
          }
          int run = 0;
          boolean first = true;
          StringBuilder result = new StringBuilder();
          for (char c : s.toCharArray()) {
            char o = Character.toLowerCase(c);
            if (c != o) {
              if (run == 0 && !first) {
                result.append('_');
              }
              run ++;
            } else {
              if (run > 1) {
                char prev = result.charAt(result.length()-1);
                result.setCharAt(result.length()-1, (char)'_');
                result.append(prev);
              }
              run = 0;
              first = false;
            }
            result.append(o);
          }
          return result.toString();
        }
        def keys_to_snake_case_recursive(Map object) {
          return object.entrySet().stream().collect(
            Collectors.toMap(
              e -> to_snake_case(e.getKey()),
              e -> e.getValue() instanceof Map? keys_to_snake_case_recursive(e.getValue()) : e.getValue()
            )
          );
        }
        ctx.cyberarkpas.audit = keys_to_snake_case_recursive(ctx.cyberarkpas.audit);

  ########################################################
  # ECS enrichment
  #
  # All processors from this point use the snake_case form
  # to access Cyberark fields.
  ########################################################

  - set:
      field: event.code
      value: '{{ cyberarkpas.audit.message_id }}'
      ignore_empty_value: true

  - set:
      field: source.address
      value: '{{ cyberarkpas.audit.station }}'
      ignore_empty_value: true

  #
  # Populate ip/host fields from address.
  #
  - grok:
      field: source.address
      patterns:
        - "(?:%{IP:source.ip}|%{GREEDYDATA:source.domain})"
      ignore_failure: true

on_failure:
  - append:
        field: error.message
        value: "{{ _ingest.on_failure_message }}"
  - remove:
      field:
        - _tmp
      ignore_missing: true
